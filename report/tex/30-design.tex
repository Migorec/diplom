\chapter{Конструкторский раздел}

В данном разделе проводится выбор синтаксиса описания моделей в разрабатываемой системе, описываются алгоритмы и структуры данных, используемые при формировании моделей и непосредственно при моделировании, а также проводится построение аналитической и имитационной модели учебной системы описанной в предыдущем разделе.



\section{Требования к синтаксису}

Синтаксис разрабатываемой системы должен быть, на сколько это возможно, схож с синтаксисом системы GPSS. 

Программа на языке GPSS представляет из себя последовательность операторов, каждый из которых описывает тот или иной элемент модели (функцию, блок, устройство и др.). Этот подход естественен для императивных языков программирования, в которых программа является последовательностью команд, меняющих состояние программы. Однако Haskell относится к категории функциональных языков, программы на которых описываются как функции, значение которых вычисляется. При этом нет фиксированной, заданной программистом, последовательности операций, которые должны быть выполнены для достижения результата. 

Тем не менее, в языке Haskell предусмотрен механизм, позволяющий описать конкретную последовательность вычислений~--- монады. В сочетании с так называемой do-нотацией, этот механизм позволит проводить описание моделей на Haskell, используя синтаксис схожий с GPSS.

\section{Монады}

Понятие монады в языке Haskell основано на теории категорий. В рамках данной теории монада может быть определена (не вполне строго) как моноид в категории эндофункторов. Однако для практического использования этого понятия в рамках языка Haskell можно обойтись менее формальным определением.

В соответствии с \cite{Haskell} монада~--- это контейнерный тип данных (то есть такой, который содержит в себе значения других типов), представляющий собой экземпляр класса Monad определенного в модуле Prelude. 

Под классом в Haskell, понимается не тип данных, как в объектно-ориентированных языках, а набор методов (функций), которые применимы для работы с теми или иными типами данных, для которых объявлены экземпляры заданных классов. Наиболее близким аналогом классам в Haskell являются интерфейсы в таких языках как Java или C\#. Более точно их следует называть классами типов, но т.к. в данной работе используется исключительно функциональная парадигма, в дальнейшем для краткости они будут называться просто классами.

Значения монад можно воспринимать, как значения м некоторым дополнительным контекстом. В случае монады Maybe значения обладают дополнительным контекстом того, что вычисления могли закончиться неуспешно. Монада IO добавляет контекст, указывающий что получение значений связано с действиями ввода/вывода и потому не является детерминированным и может иметь побочные эффекты. В случае списков (которые также являются монадой) контекстом является то, что значение может являться множественным или отсутствовать.

Класс Monad определен в модуле Prelude следующим образом:

\lstinputlisting[caption=Класс Monad,label=lst:monad]{inc/src/Monad.hs}

Функция \Code{return}\footnote{Следует отметить, что название return никак нельзя назвать удачным, так как оно неизбежно вызывает ассоциации с одноименным оператором из многих императивных языков программирования, на которые она не похожа ничем кроме названия. Данная функция не завершает выполнение функции, а лишь оборачивает переданное значение в монаду.} преобразует переданное ей значение типа a  в монадическое значение типа m a. Другими словами она помещает значение в некоторый контекст по умолчанию, в зависимости от выбранной монады. Для списка это будет список из одного элемента, для монады IO~--- действие ввода вывода, всегда возвращающее заданное значение и не имеющее побочных эффектов и т.д.

Функция \Code{$>>=$} определяет операцию связывания. Она принимает монадическое значение и передает его функции, которая принимает обычное значение и возвращает монадическое. При этом сохраняется накопленный контекст и к нему добавляется новый, полученный в результате выполнения функции.

Функция \Code{$>>$} также предназначена для связывания и используется в тех случаях, когда переданное монадическое значение не представляет интереса, а значение имеет только переданный с ним контекст вычислений. Для этой функции в классе определена реализация по умолчанию, по этому в большинстве случаев при определении экземпляра класса Monad в явном виде ее не реализуют.

Функция \Code{fail} никогда не вызывается программистом явным образом и предназначена для обработки неуспешного окончания вычислений при сопоставлении с образцом в do-нотации, что позволяет избежать аварийного завершения программы и вернуть неудачу в контексте текущей монады.

\section{Нотация do}

Так как монады находят крайне широкое применение в программах на языке Haskell (в первую очередь, без использования монады IO невозможно осуществить ввод/вывод), в синтаксис языка было добавлено специальное ключевое слово \Code{do}, призванное упростить написание монадических функций, сделать их более читаемыми и избавить от излишнего <<синтаксического мусора>>.

Если в коде программы встречается конструкция с ключевым словом \Code{do}, то транслятор выполняет следующие преобразования\footnote{В приведенных преобразованиях используются управляющие символы \Code{;}, \Code{\{} и \Code{\}}, хотя в реальных программах на языке Haskell их можно встретить довольно редко. Это связано с тем, что в Haskell используется так называемый <<двумерный синтаксис>>: при правильной расстановке отступов, транслятор самостоятельно расставляет точки с запятой и фигурные скобки и в большинстве случаев нет смысла загромождать ими исходный код. Тем не менее в случае необходимости их можно расставить и явным образом.}:

\begin{verbatim}
1. do {e} → e
2. do {e; es} → e >> do {es}
3. do {let decls; es} → let decls in do {es}
4. do {p <- e; es} → let ok p = do {es}
                          ok _ = fail "..."
                      in e >>= ok
\end{verbatim}

При помощи нотации \Code{do} приведенный ниже фрагмент кода

\begin{verbatim}
foo :: Maybe String
foo = Just 3 >>= (\x -> Just "!" >>= (\y -> Just (show x ++ y)))}
\end{verbatim}

может быть записан в следующей более читаемой форме:

\begin{verbatim}
foo :: Maybe String
foo = do x <- Just 3 
         y <- Just "!" 
         return (show x ++ y)
\end{verbatim}

\section{Монада State}

Часто в процессе вычислений возникает необходимость хранить и изменять некоторое состояние, в зависимости от которого результат вычислений может меняться. Haskell является чистым функциональным языком программирования функции должны быть детерминированы и не иметь побочных эффектов, поэтому текущее состояние обычно передается в функции как еще один параметр, а возвращает функция пару из собственно результата и обновленного состояния.

Для того, чтобы упростить написание функций оперирующих некоторым состоянием в Haskell была введена монада \Code{State}. Она определена в модуле \Code{Control.Monad.State} следующим образом:

\begin{verbatim}

newtype State s a = State {runState :: s -> (a, s)}

instance Monad (State s) where
    return x = State $ \s -> (x,s)
    (State h) >>= f = State $ \s -> let (a, newState) = h s
                                        (State g) = f a
                                    in g newState

\end{verbatim}

Функция \Code{return} создает вычисление с состоянием, которое всегда возвращает один и тот же результат и оставляет переданное в него состояние без изменений. Функция \Code{$>>=$} <<склеивает>> два вычисления с состоянием так, что конечное  состояние первого становится начальным для второго, а результат и конечное состояние второго вычисления становятся также результатом и конечным состоянием итогового, составного вычисления.

Помимо этого для работы с монадой \Code{State} используются две вспомогательные функции \Code{put} и \Code{get}. Функция \Code{put} является вычислением, которое устанавливает состояние в заданное значение не зависимо от его предыдущего значения и не возвращает никакого результата (точнее возвращает кортеж нулевой длины \Code{()}). Функция \Code{get} возвращает текущее состояние и оставляет его без изменений. 

\section{Описание модели как вычисление с состоянием}

Описание модели на языке GPSS представляет из себя последовательность блоков. В Haskell такое описание удобно представить как последовательность функций, каждая из которых добавляет к уже сформированной модели очередной блок. 

Такой процесс удобно представить как вычисление с состоянием. Каждая функция, формирующая блок, помимо параметров самого блока должна принимать текущее состояние~--- список уже сформированных к данному моменту боков в порядке их формирования. В качестве результата функция возвращает новое состояние~--- модель к которой добавлен только что сформированный блок (см. Рисунок \ref{fig:StateIDEF}).

\begin{figure}[ht]
  \centering
  \includegraphics[width=\textwidth]{inc/dia/StateIDEF}
  \caption{Процесс формирования модели}
  \label{fig:StateIDEF}
\end{figure}

Для реализации такого механизма целесообразно воспользоваться монадой \Code{State}, что позволит скрыть явную передачу состояния от одной функции к другой. А использование нотации \Code{do} сделает описание модели почти идентичным синтаксису GPSS:

\begin{verbatim}

model = 
    do generate (10,2)
       advance 3
       terminate 1

\end{verbatim}


\section{Функции формирования блоков}

В языке GPSS имена всех блоков пишутся с заглавной буквы. Параметры отделяются от имени блока пробелом и разделяются запятыми. Синтаксис Haskell не позволяет в точности повторить эти соглашения. Имена функций в Haskell обязаны начинаться со строчной буквы. Параметры функций обычно разделяются пробелами и не берутся в скобки (каррированные функции) либо заключаются в скобки и разделяются запятыми (не каррированные функции)\footnote{Строго говоря все функции в Haskell принимают ровно один параметр. Функции от N параметров на самом деле принимают один параметр и возвращают функцию от N-1 параметра (каррированные функции) либо принимают параметр-кортеж (некаррированные).}. Оба варианта описания параметров одинаково близки к синтаксису GPSS и можно выбрать любой из них, однако для второго варианта существенно легче реализовать перегрузку функций.

\section{Состояние транзакта}

Основным объектом в процессе моделирования является транзакт. Моделирование представляет собой передвижение транзактов от блока к блоку, в процессе которого могут изменяться состояния тех или иных объектов системы (обслуживающих аппаратов, очередей, хранилищ).

Параметры, определяющие состояние транзакта приведены в таблице~\ref{tab:transactionState}

\begin{table}
\caption{Параметры состояния транзакта}
\label{tab:transactionState}
\begin{tabular}{|l|l|p{0.6\textwidth}|}
\hline
Имя параметра & Тип &Описание \\
\hline
currentBlock & Int & Номер блока модели, в котором в данный момент находится транзакт.\\
\hline
nextBlock & Int & Номер блока в который транзакт попытается перейти.\\
\hline
priority & Int & Приоритет транзакта.\\
\hline
params & IntMap Double & Массив параметров транзакта.\\
\hline
ownership & String & Имя устройства, на котором в данный момент обрабатывается транзакт.\\
\hline
\end{tabular}
\end{table}

Также как часть состояния транзакта моет рассматриваться информация о том, в каком из глобальных или локальных списков событий он находится в данный момент. Так как в каждый момент транзакт должен находиться только в одном из списков, хранить ту информацию в отдельном поле не целесообразно.

\section{Состояния объектов системы}

В процессе перемещения по блокам транзакты изменяют состояния других объектов системы. Эти состояния во-первых, в свою очередь, оказывает влияние на движение транзактов, а во-вторых предназначено для сбора статических данных в процессе моделирования.

Параметры состояний обслуживающих аппаратов, хранилищ и очередей приведены в таблицах~\ref{tab:facState},~\ref{tab:storState} и \ref{tab:queueState} соответственно.

\begin{table}
\caption{Параметры состояния обслуживающего аппарата}
\label{tab:facState}
\begin{tabular}{|l|l|p{0.6\textwidth}|}
\hline
Имя параметра & Тип & Описание \\
\hline
idAvailable & Bool & Флаг, показывающий доступно или занято в данный момент обслуживающее устройство\\
\hline
toInterupted & Bool & Флаг, показывающий, захватил ли, обрабатывающийся в данный момент транзакт, устройство обычным образом или путем вытеснения обрабатывавшегося до этого транзакта.\\
\hline
captureCount & Int & Счетчик, показывающий сколько раз было захвачено данной устройство.\\
\hline
captureTime & Double & Суммарное время, в течение которого устройство было занято.\\
\hline
lastCaptureTime & Double & Момент времени, когда устройство было захвачено в последний раз.\\
\hline
utilization & Double & Процент времени, в течении которого устройство было занято.\\
\hline
ownerPriority & Int & Приоритет транзакта, обслуживающегося на устройстве в данный момент. \\
\hline
dc & [Transaction] & Список заявок, ожидающих освобождения устройства. \\
\hline
ic & \parbox{25mm}{[(Maybe Double,\\Transaction)] }  & Список заявок, вытесненных с устройства и ожидающих его освобождения для продолжения обслуживания.\\
\hline
pc & [Transaction] & Список заявок, не сумевших вытеснить, обрабатываемый в данный момент транзакт, и ожидающих освобождения устройства.\\
\hline
\end{tabular}
\end{table}


\begin{table}
\caption{Параметры состояния хранилища}
\label{tab:storState}
\begin{tabular}{|l|l|p{0.65\textwidth}|}
\hline
Имя параметра & Тип & Описание \\
\hline
capacity & Int & Емкость хранилища.\\
\hline
unused & Int & Число доступных единиц ресурса в хранилище.\\
\hline
avgInUse & Double & Среднее число занятых единиц ресурса.\\
\hline
useCount & Int & Число захватов ресурса за время моделирования.\\
\hline
lastMod & Double & Момент последнего захвата или освобождения ресурса.\\
\hline
utilization & Double &Средний процент захваченных единиц ресурса.\\
\hline
maxInUse & Int & Максимальное число одновременно захваченных единиц ресурса. \\
\hline
dc & [Transaction] & Список заявок, ожидающих освобождения достаточного числа ресурсов хранилища. \\
\hline
\end{tabular}
\end{table}


\begin{table}
\caption{Параметры состояния очереди}
\label{tab:queueState}
\begin{tabular}{|l|l|p{0.65\textwidth}|}
\hline
Имя параметра & Тип & Описание \\
\hline
currentContent & Int & Число заявок в очереди в данный момент модельного времени.\\
\hline
maximumContent & Int & Максимальное число заявок в очереди за все время моделирования.\\
\hline
averageContent & Double & Среднее число заявок в очереди.\\
\hline
lastChangeTime & Double & Момент времени, когда в последний раз заявка встала в очередь или покинула ее.\\
\hline
\end{tabular}
\end{table}


\section{Состояние системы в целом}

В процессе имитационного моделирования система последовательно переходит из одного состояния в другое, до тех пор, пока не будет достигнуто некоторое условие остановки моделирования. В данном случае моделирование происходит до тех пор, пока в блоках TERMINATE не будет завершено заданное число транзактов.

Состояние моделируемой системы может быть описано параметрами, указанными в таблице~\ref{tab:simState}. Моделирование продолжается до тех пор, пока значение параметра \Code{toTerminate} не достигнет нуля.

Отношения перечисленных сущностей показаны на рисунке~\ref{fig:umlSim}.

\begin{figure}[ht]
  \centering
  \includegraphics[width=\textwidth]{inc/dia/er}
  \caption{Отношения между сущностями системы}
  \label{fig:umlSim}
\end{figure}


\begin{table}[ht!]
\caption{Параметры состояния системы}
\label{tab:simState}
\begin{tabular}{|l|l|p{0.5\textwidth}|}
\hline
Имя параметра & Тип & Описание \\
\hline
currentTime & Double & Текущий момент модельного времени.\\
\hline
toTerminate & Int & Число транзактов, которое необходимо завершить для окончания моделирования.\\
\hline
blocks & Array Int SBlock & Список блоков, составляющих модель.\\
\hline
facilities & Map String Facility & Список состояний обслуживающих аппаратов.\\
\hline
storages & Map String Storage & Список состояний хранилищ.\\
\hline
queues & Map String Queue & Список состояний очередей.\\
\hline
cec & [Transaction] & Список будущих событий~--- список транзактов, продвижение которых требует наступления некоторого момента модельного времени. Упорядочен по возрастанию ожидаемого момента времени. \\
\hline
fec & [(Double,Transaction)] & Список текущих событий~--- список транзактов, продвижение которых возможно в данный момент модельного времени. Упорядочен по убыванию приоритета транзактов. \\
\hline
\end{tabular}
\end{table}


\section{Алгоритм имитационного моделирования}

Процесс моделирования запускается при вызове функции, одним параметром которой является сформированная модель, а вторым~--- количество транзактов, которое необходимо завершить для окончания моделирования.

На первом шаге алгоритма происходит активация всех блоков GENERATE. Для каждого из них вычисляется время создания ближайшего транзакта и эти транзакты помещаются в список будущих событий.

На втором шаге из списка будущих событий извлекаются события, наступающие в ближайший момент модельного времени. Модельное время передвигается на момент наступления тих событий, а сами события помещаются в  список текущих событий. 

На третьем шаге, до тех пор пока список текущих событий не опустеет, происходит продвижение транзакта из того списка с наибольшим приоритетом. Продвижение каждого транзакта происходит до тех пор, пока транзакт тем или иным образом не покинет текущий список (например, войдет в блок ADVANCE и будет помещен в список будущих событий или попытается войти в блок занятого устройства и попадет в список транзактов, ожидающих освобождения того устройства).

Шаги два и три повторяются до тех пор, пока в процессе моделирования не будет завершено заданное число транзактов. Схема алгоритма показана на рисунке~\ref{fig:simFlowchart}.

\begin{figure}[ht]
  \centering
  \includegraphics[height=0.7\textheight]{inc/dia/simFlowchart}
  \caption{Алгоритм имитационного моделирования}
  \label{fig:simFlowchart}
\end{figure}


\section{Обработка захода транзакта в блок}

Каждый раз, когда заявка пытается зайти в очередной блок, вызывается функция обработчик, которая определяет, может ли транзакт это сделать и какие дополнительные действия при этом должны быть выполнены. Исключением является блок GENERATE, для которого обработчик (определяющий время создания нового транзакта) вызывается при выходе из него транзакта. 

Обработчики индивидуальны для каждого типа блоков. В качестве примера на рисунках~\ref{fig:enterFlowchart} и \ref{fig:leaveFlowchart} показаны алгоритмы обработчиков блоков ENTER и LEAVE соответственно.

\begin{figure}[ht]
  \centering
  \includegraphics[width=\textwidth]{inc/dia/enterFlowchart}
  \caption{Алгоритм обработки блока ENTER}
  \label{fig:enterFlowchart}
\end{figure}

\begin{figure}[ht]
  \centering
  \includegraphics[width=\textwidth]{inc/dia/leaveFlowchart}
  \caption{Алгоритм обработки блока LEAVE}
  \label{fig:leaveFlowchart}
\end{figure}

При входе транзакта в блок ENTER проверяется количество свободных единиц ресурса в соответствующем хранилище. Если ресурса достаточно, то транзакт успешно входит в блок, количество доступных ресурсов уменьшается и обновляется статистика использования хранилища. Затем транзакт продолжает движение по блокам. Если же транзакту требуется больше ресурсов, чем в данный момент есть в хранилище, транзакт попадает в список транзактов, ожидающих освобождения ресурсов.

При входе транзакта в блок LEAVE освобождается указанное количество ресурсов соответствующего хранилища и транзакт продолжает движение по блокам. Если есть транзакты, ожидающие освобождения ресурса, среди них выбирается транзакт с наибольшим приоритетом и делается попытка выделить ему необходимое количество ресурса. Если это удается, то транзакт помещается в список текущих событий, в противном случае он возвращается в список ожидания.

\section{Структура библиотеки}

На рисунке~\ref{fig:libStruct} показана общая структура спроектированной библиотеки.

\begin{figure}[ht]
  \centering
  \includegraphics[width=\textwidth]{inc/dia/libStructHuge}
  \caption{Структура разработанной библиотеки}
  \label{fig:libStruct}
\end{figure}

На диаграмме можно выделить:

\begin{itemize}
\item {Модуль с описанием различных типов блоков и их параметров.}
\item {Группу модулей, ответственных за описание состояния модели (в частности модули со структурами заявок, хранилищ, очередей и т.п.).}
\item {Модуль содержащий непосредственно алгоритм имитационного моделирования.}
\item {Группу модулей с обработчиками захода транзактов в те или иные блоки.}
\item {Модуль формирующий результаты моделирования на основе заключительного состояния системы.}
\item {Группу модулей предназначенных для формирования моделируемой системы и содержащие функции добавляющие в систему те или иные блоки.}
\item {Интерфейсный модуль, реэкспортирующий все необходимые сущности библиотеки и предназначенный для непосредственного подключения к прикладной программе.}

\end{itemize}

\section{Демонстрационная программа}

Для демонстрации возможностей спроектированной библиотеки, а также с целью удостовериться  в адекватности выбранных алгоритмов моделирования и верности их реализации, целесообразно разработать демонстрационную программу. 

Проектируемая программа должна проводить решение приведенной в предыдущем разделе задачи аналитически и при помощи разработанной библиотеки при различных входных параметрах и выводить результаты в удобной для сравнения форме. Целесообразно также предусмотреть возможность автоматического варьирования выбранного параметра модели и построения графика зависимости результата от этого параметра при фиксированных прочих для аналитической и имитационной модели.

Предполагаемая структура такой программы показана на рисунке~\ref{fig:demoStruct}.

\begin{figure}[ht]
  \centering
  \includegraphics[width=\textwidth]{inc/dia/demoStruct}
  \caption{Структура демонстрационной программы}
  \label{fig:demoStruct}
\end{figure}

\section{Аналитическая модель системы}

Ниже представлен способ аналитического вычисления характеристик системы приведенной в предыдущем разделе.При выводе формул использовались методы укрупнения модели и укрупнения состояний описанные в~\cite{Kurov}.

\subsection{Моделирование отказов и восстановлений}
Состояние системы можно описать вектором $ \xi (t) = (\xi_{1}(t),\,\xi_{2}(t))$, где $\xi_{1}(t)$~--- число неисправных процессоров в момент времени $t$, $\xi_{2}(t)$~--- число неисправных каналов в момент времени $t$.

На рисунке~\ref{fig:broke-graph} показана структура фрагмента графа состояний системы, где $\beta_{ij}=\beta\frac{i}{i+j}min\left\lbrace i+j,L\right\rbrace$, $\delta_{ij}=\delta\frac{j}{i+j}min\left\lbrace i+j,L\right\rbrace$. 
\begin{figure}[ht]
\centering
\includegraphics[height=6cm]{inc/dia/broke-graph}
\caption{Структура фрагмента графа состояний системы}
\label{fig:broke-graph}
\end{figure}

Проведем укрупнение состояний системы. Объединим в одно макросостояние все вершины графа, у которых одинаковым является первый компонент $\xi_{1}(t)$~--- число неисправных процессоров. Полученный граф представлен на рисунке~\ref{fig:broke-proc}, где $\beta_i=\beta\sum\limits_{j=0}^N\pi_j\frac{i}{i+j}min\left\lbrace i+j,L\right\rbrace$, $\pi_j$~--- вероятность того, что отказали ровно j каналов.

\begin{figure}[ht]
\centering
\includegraphics[width=\textwidth]{inc/dia/broke-proc}
\caption{Граф состояний системы}
\label{fig:broke-proc}
\end{figure}

Тогда выражения для определения вероятностей стационарных состояний примут вид:

\begin{equation}
\label{eq:broke-proc}
\left\{
   \begin{array}{lcl}
	p_{0} = \left( 1 + \dfrac{M \alpha}{\beta_1} +  ... + \dfrac{M! \alpha^{M}}{\prod \limits_{i=1}^M \beta_i} \right) ^{-1} \\
	p_{i} = p_{0} \dfrac{\alpha^{i}\prod \limits_{j=1}^{i} (M-j+1)}{\prod \limits_{j=1}^i \beta_{j}}, \quad i = \overline{1,M}  \\ 
	\beta_i=\beta\sum\limits_{j=0}^N\pi_j\frac{i}{i+j}min\left\lbrace i+j,L\right\rbrace
   \end{array}
\right.
\end{equation}
 
Аналогичным образом объединим в одно макросостояние все вершины графа, у которых одинаковым является второй компонент $\xi_{2}(t)$~--- число неисправных каналов. Полученный граф представлен на рисунке~\ref{fig:broke-chan}, а выражения для определения вероятностей стационарных состояний примут вид:

\begin{equation}
\label{eq:broke-chan}
\left\{
   \begin{array}{lcl}
	\pi_{0} = \left( 1 + \dfrac{N \gamma}{\delta_1} +  ... + \dfrac{N! \gamma^{N}}{\prod \limits_{i=1}^N \delta_i} \right) ^{-1} \\
	\pi_{i} = \pi_{0} \dfrac{\gamma^{i}\prod \limits_{j=1}^{i} (N-j+1)}{\prod \limits_{j=1}^i \delta_{j}}, \quad i = \overline{1,N}  \\ 
	\delta_j=\delta\sum\limits_{i=0}^M p_i\frac{j}{i+j}min\left\lbrace i+j,L\right\rbrace
   \end{array}
\right.
\end{equation}

\hfill

\begin{figure}[ht]
\centering
\includegraphics[width=\textwidth]{inc/dia/broke-chan}
\caption{Граф состояний системы}
\label{fig:broke-chan}
\end{figure}

\hfill

Применяя формулы~\ref{eq:broke-proc} и~\ref{eq:broke-chan} итеративно получим вероятности отказов процессоров и каналов в системе. В качестве начального приближения можно взять $\pi_i=\frac{1}{M}$

\hfill

\subsection{Укрупнение модели}

\hfill

Заменим исходную модель агрегированной однофазной моделью АМ1 (см. рисунок~\ref{fig:AM1}). В агрегированный узел объединена подсистема, включающая в себя процессоры и каналы. Интенсивность обслуживания в этом узле зависит от числа находящихся в нем заявок.

\hfill

\begin{figure}[ht]
\centering
\includegraphics[height=7cm]{inc/dia/AM1}
\caption{Укрупненная модель АМ1}
\label{fig:AM1}
\end{figure}

\hfill

Граф состояний полученной системы представлен на рисунке~\ref{fig:graphAM1}. Производительность системы может быть вычислена по формулам:


\begin{equation}
\label{eq:AM1}
\left\{
   \begin{array}{lcl}
	\hat{\pi}_{0} = \left( 1 + \dfrac{K \lambda}{\xi_1} +  ... + \dfrac{K! \lambda^{K}}{\prod \limits_{i=1}^K \xi_i} \right) ^{-1} \\
	\hat{\pi}_{i} = \hat{\pi}_{0} \dfrac{\lambda^{i}\prod \limits_{j=1}^{i} (K-j+1)}{\prod \limits_{j=1}^i \xi_{j}}, \quad i = \overline{1,K}  \\ 
	\xi_{ср}^{*}=\sum \limits_{i=1}^K \xi_i \hat{\pi_i}
   \end{array}
\right.
\end{equation}


\begin{figure}[ht]
\centering
\includegraphics[width=\textwidth]{inc/dia/graphAM1}
\caption{Граф состояний модели АМ1}
\label{fig:graphAM1}
\end{figure}

Однако, чтобы воспользоваться приведенными формулами, необходимо знать параметры связи $\mu_i$. Чтобы их найти, рассмотрим укрупненную модель АМ2, структура и граф состояний которой показаны на рисунках~\ref{fig:AM2} и~\ref{fig:graphAM2}. За состояние системы примем количество заявок на процессорной фазе, а интенсивности переходов могут быть выражены по формулам:

\begin{equation}
\label{eq:mu}
\mu_i = \mu \sum \limits_{j=0}^M p_j min \left\lbrace i, M-j \right\rbrace
\end{equation}

\begin{equation}
\label{eq:nu}
\nu_i = \nu \sum \limits_{j=0}^N \pi_j min \left\lbrace n-i+1, N-j \right\rbrace
\end{equation}



\begin{figure}[ht]
\centering
\includegraphics[height=7cm]{inc/dia/AM2}
\caption{Укрупненная модель АМ2}
\label{fig:AM2}
\end{figure}

\begin{figure}[ht]
\centering
\includegraphics[width=\textwidth]{inc/dia/graphAM2}
\caption{Граф состояний модели АМ2}
\label{fig:graphAM2}
\end{figure}


Параметр связи может вычислен по следующим формулам:


\begin{equation}
\label{eq:AM2}
\left\{
   \begin{array}{lcl}
	\hat{p}_{0} = \left( 1 + \dfrac{\nu_1}{\mu_1} +  ... + \dfrac{\prod \limits_{i=1}^n \nu_i}{\prod \limits_{i=1}^n \mu_i} \right) ^{-1} \\
	\hat{p}_{i} = \hat{p}_{0} \dfrac{\prod \limits_{j=1}^{i} (\nu_j)}{\prod \limits_{j=1}^i \mu_{j}}, \quad i = \overline{1,n}  \\ 
	\xi_n = \sum \limits_{i=1}^n \hat{p}_i \mu_i
   \end{array}
\right.
\end{equation}


\subsection{Окончательная расчетная схема}
Последовательность расчета производительности системы должна быть следующей (см. рисунок~\ref{fig:idefAnalit}):

\begin{enumerate}
\item По формулам~\ref{eq:broke-proc} и ~\ref{eq:broke-chan} вычислить $\pi_i, i=\overline{0,N}$ и $p_i, i=\overline{0,M} $.
\item По формулам~\ref{eq:mu},~\ref{eq:nu} и~\ref{eq:AM2} вычислить $\xi_n, n=\overline{1,K}$.
\item Вычислить $\xi^{*}$ по формулам~\ref{eq:AM1}.
\end{enumerate}


\begin{figure}[ht!]
\centering
\includegraphics[width=0.9\textheight,angle=-90]{inc/dia/idefAnalit}
\caption{Последовательность расчета производительности системы}
\label{fig:idefAnalit}
\end{figure}

\section{Имитационная модель}

Ниже представлена имитационная модель демонстрационной системы, реализованная при помощи разработанной системы моделирования.

\subsection{Моделирование многоканальных обслуживающих устройств}

Так как в исследуемой системе используются многоканальные обслуживающие устройства, каждый из каналов которых может выйти из строя независимо от других, не представляется возможным промоделировать их при помощи хранилищ (хранилища могут быть отключены только целиком и не поддерживают вытеснение транзактов). Поэтому придется каждый канал обслуживающего устройства моделировать отдельным многоканальным устройством, а выбор транзактом свободного канала осуществлять при помощи блока TRANSFER, работающего в режиме ALL.

Ниже приведен код функции, формирующий часть модели, ответственную за обслуживание заявки на одном из процессоров. В качестве параметров функция принимает номер процессора, интенсивность обработки и метку блока с которого начинается следующая фаза обслуживания.

\begin{verbatim}
proc i mu l =
    do seize ("proc" ++ show i)
       advance (1/mu, xpdis)
       release ("proc" ++ show i)
       transfer ((),l)
\end{verbatim}

\subsection{Моделирование отказов и восстановлений}

Для моделирования отказов и восстановления каждого из каналов используется отдельный транзакт, который сперва захватывает соответствующее устройство при помощи блока PREEMPT в режиме прерывания (после этого устройство становится недоступно для транзактов, моделирующих задачи), после этого пытается захватить ресурс хранилища, моделирующего ремонтные бригады, и после того через некоторое время освобождает устройство и ресурс (устройство восстановлено и снова доступно для обработки задач). Время, остававшееся до окончания обработки транзакту, вытесненному в момент поломки, сохраняется в  параметре транзакта, а сам транзакт перенаправляется на фазу дообслуживания.


Ниже приведен код функции, формирующей часть модели ответственную за отказы и восстановления одного из процессоров. В качестве параметров функция принимает номер процессора, интенсивности его отказов и восстановлений и метку блока, с которого начинается фаза дообслуживания.

\begin{verbatim}
breakReairProc i alpha beta l' = 
    do generate (0,0,0,1)
       l <- advance (1/alpha, xpdis)
       preempt ("proc" ++ show i, (), l', 1, RE)
       enter "repairers"
       advance (1/beta,xpdis)
       return' ("proc" ++ show i)
       leave "repairers"
       transfer ((),l)
\end{verbatim}

Функция формирующая фазу дообслуживания во всем подобна функции \Code{proc} за исключением того, что время обслуживания берется из параметра транзакта, а не определяется случайным образом.

\begin{verbatim}
procFinish i l =
    do seize ("proc" ++ show i)
       advance (Pr 1)
       release ("proc" ++ show i)
       transfer ((),l)
\end{verbatim}

\subsection {Общая модель системы.}

Функция формирующая при помощи вышеописанных общую модель системы показана ниже. В качестве параметров она принимает все параметры системы (количество задач, процессоров, каналов и ремонтных бригад и интенсивности обработки на различных фазах и отказов и восстановлений).

\begin{verbatim}
model m n k l lambda mu nu alpha beta gamma delta = 
    do storage ("repairers", l)
       generate (0,0,0,1)
       advance 100
       terminate 1
       
       generate (0,0,0,k)
       userPhase <- advance (1/lambda, xpdis)
       seize "counter"
       release "counter"
       procStart <- transfer (All,userPhase +5, 
                              userPhase + 5 + (m-1)*4,4)
       chanStart <- transfer (All,userPhase +5+4*m, 
                              userPhase + 5 + m*4 + (n-1)*4,4)
       mapM_ (\i -> proc i mu chanStart) [1..m]
       ls <- mapM (\i -> chan i nu userPhase) [1..n]
       
       let l = fromIntegral $ last ls
       procFinishL <- transfer (All,l + 3,
                                l + 3 + (m-1)*4,4)
       chanFinishL <- transfer (All,l + 3 + 4*m,
                                l + 3 + 4*m + (n-1)*4,4)
       mapM_ (\i -> procFinish i chanStart) [1..m]
       mapM_ (\i -> chanFinish i userPhase) [1..n]
       
       when (alpha > 0) $ mapM_ (\i -> breakReairProc 
                                         i alpha beta procFinishL
                                ) [1..m]
       when (gamma > 0) $ mapM_ (\i -> breakReairChan 
                                         i gamma delta chanFinishL
                                ) [1..n]
\end{verbatim}

 Первым делом функции объявляется хранилище емкостью равной числу ремонтных бригад. Затем создается группа блоков ответственная за ограничение времени моделирования.

Последующие блоки отвечают за создание транзактов, моделирующих задачи пользователей и время их обдумывания пользователем. Далее следуют блоки TRANSFER предназначенные для передачи заявки на свободный в данный момент процессор или канал. Далее путем многократного вызова функций \Code{proc} и \Code{chan} формируется часть модели ответственная за обработку задач на процессорной и канальной фазах. 

Далее аналогичным образом, при помощи блоков TRANSFER и многократного вызова функций \Code{procFinish} и \Code{chanFinish} формируются фазы дообслуживания. 

И в заключение при помощи функций \Code{breakReairProc} и \Code{breakReairChan} формируются блоки моделирующие отказы и восстановления.

\section{Выводы}

В результате проектирования был разработан синтаксис и алгоритм описания моделей, а также алгоритмы и структуры данных необходимые для имитационного моделирования. Были спроектированы структуры библиотеки имитационного моделирования и демонстрационной программы, призванной проиллюстрировать ее работу. Были разработаны аналитическая и имитационная модели демонстрационной системы, описанной в предыдущем разделе.
