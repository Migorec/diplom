\chapter{Конструкторский раздел}

В данном разделе проводится выбор синтаксиса описания моделей в разрабатываемой системе, а также описываются алгоритмы и структуры данных, используемые при формировании моделей и непосредственно при моделировании. 



\section{}

Синтаксис разрабатываемой системы должен быть, на сколько это возможно, схож с синтаксисом системы GPSS. 

Программа на языке GPSS представляет из себя последовательность операторов, каждый из которы описывает тот или иной элемент модели (функцию, блок, устройство и др.). Этот подход естественен для императивных языков программирования, в которых программа является последовательностю комманд, меняющих состояние программы. Однако Haskell относится к категории функциональных языков, программы на которых лписываются как функции, значение которых вычисляется. При этом нет фиксированной, заданной программистом, последовательности операций, которые должны быть выполнены для достижения результата. 

Тем не менее, в языке Haskell предусмотрен механизм, позволяющий описать конкретную последовательность вычислений~--- монады. В сочетании с так называемой do-нотацией, этот механизм позволит проводить описание моделей на Haskel, используя синтаксис схожий с GPSS.

\section{Монады}

Понятие монады в языке Haskell основано на теории категорий. В рамках данной теории монадо может быть определена (не вполне строго) как моноид в категории эндофункторов. Однако для практического использования этого понятия в рамках языка Haskell можно обойтись менее формальным определением.

В соответствии с \cite{Haskell} монада~--- это контейнейрный тип данных (то есть такой, который содержит в себе значения других типов), представляющий собой экземпляр класса Monad определенного в модуле Prelude. 

Под классом в Haskell, понимается не тип данных, как в объектно-оринтированных языках, а набор методов (функций), которые применимы для работы с теми или иными типами данных, для которых объявлены экземпляры заданных классов. Наиболее близким аналогом классам в Haskell являются интерфейсы в таких языках как Java или C\#. Более точно их следует называть классами типов, но т.к. в данной работе используется исключительно функциональная парадигма, в дальнейшем для краткости они будут называться просто классами.

Значения монад можно воспринимать, как значения м неккоторым дополнительным контекстом. В случае монады Maybe значения обладают дополнительным контекстом того, что вычисления могли закончиться неуспешно. Монада IO добавляет контекст, указывающий что получение значений связано с действиями ввода/вывода и потому не является детерминированным и может иметь побочные эффекты. В случае списков (которые также являются монадой) контекстом является то, что значение может являться множественным или отсутствовать.

Класс Monad определен в модуле Prelude следующим образом:

\lstinputlisting[caption=Класс Monad,label=lst:monad]{inc/src/Monad.hs}

Функция \Code{return}\footnote{Следует отметить, что название return никак нельзя назвать удачным, так как оно неизбежно вызывает ассоциации с одноименным оператором из многих императивных языков программирования, на которые она не похожа ничем кроме названия. Данная функция не завершает выполнение функции, а лишь оборачивает переданное значение в монаду.} преобразует переданное ей значение типа a  в монадическое значение типа m a. Другими словами она помещает значение в некоторый контекст по умолчанию, в зависимости от выбранной монады. Для списка это будет списко из одного элемента, для монады IO~--- действие ввода вывода, всегда возвращающее заданное значение и не имеющее побочных эффектов и т.д.

Функция \Code{$>>=$} определяет операцию связывания. Она принимает монадическое значение и передает его функции, которая принимает обычное значение и возвращает монадическое. При этом сохраняется накопленный контекст и к нему добавляется новый, полученный в результате выполнения функции.

Функция \Code{$>>$} также предназначена для связывания и используется в тех случаях, когда переданное монадическое значение не представляет интереса, а значение имеет только переданный с ним контекст вычислений. Для этой функции в классе определена реализация по умолчанию, по этому в большенстве случаев при определении экземпляра класса Monad в явном виде ее не реализуют.

Функция \Code{fail} никогда не вызывается программистом явным образом и предназначена для обработки неуспешного окончания вычислений при сопоставлении с образцом в do-нотации, что позволяет избежать аварийного завершения программы и вернуть неудачу в контексте текущец монады.

\section{Нотация do}

Так как монады находят крайне широкое применение в программах на языке Haskell (в первую очередь, без использования монады IO невозможно осуществить ввод/вывод), в синтаксис языка было добавлено специальное ключевое слово \Code{do}, призванное упростить написание монадических функций, сделать их более читаемыми и избавить от излишнего <<синтаксического мусора>>.

Если в коде программы встречается контрукция с ключевым словом \Code{do}, то транслятор выполняет следующие преобразования\footnote{В приведенных преобразованиях используются управляющие символы \Code{;}, \Code{\{} и \Code{\}}, хотя в реальных программах на языке Haskell их можно встретить довольно редко. Это связано с тем, что в Haskell используется так называемый <<двумерный синтаксис>>: при правильной расстановке отступов, транслятор самостоятельно расставляет точки с запятой и фигурные скобки и в большинтве случаев нет смысла заграмождать ими исходный код. Тем не менее в случае необходимости их можно расставить и явным образом.}:

\begin{verbatim}
1. do {e} → e
2. do {e; es} → e >> do {es}
3. do {let decls; es} → let decls in do {es}
4. do {p <- e; es} → let ok p = do {es}
                          ok _ = fail "..."
                      in e >>= ok
\end{verbatim}

При помощи нотации \Code{do} приведенный ниже фрагмент кода

\begin{verbatim}
foo :: Maybe String
foo = Just 3 >>= (\x -> Just "!" >>= (\y -> Just (show x ++ y)))}
\end{verbatim}

может быть записан в следующей более читаемой форме:

\begin{verbatim}
foo :: Maybe String
foo = do x <- Just 3 
         y <- Just "!" 
         return (show x ++ y)
\end{verbatim}

\section{Монада State}

Часто в процессе вычислений возникает необходимость хранить и изменять некоторое состояние, в завсимости от которого результат вычислений может меняться. Haskell является чистым функциональным языком программирования функции должны быть детерменированы и не иметь побочных эффектов, поэтому текущее состояние обычно передается в функции как еще один параметр, а возвращает функция пару из собственно результата и обновленного состояния.

Для того, чтобы упростить написание функций оперирующих некоторым соостоянием в Haskell была введена монада \Code{State}. Она определена в модуле \Code{Control.Monad.State} следующим образом:

\begin{verbatim}

newtype State s a = State {runState :: s -> (a, s)}

instance Monad (State s) where
    return x = State $ \s -> (x,s)
    (State h) >>= f = State $ \s -> let (a, newState) = h s
                                        (State g) = f a
                                    in g newState

\end{verbatim}

Функция \Code{return} создает вычисление с состоянием, которое всегда возвращает один и тот же результат и оставляет переданное в него состояние без изменений. Функция \Code{$>>=$} <<склеивает>> два вычисления с состоянием так, что конечное  состояние первого становится начальным для второго, а результат и конечное состояние второго вычисления становятся также результатом и конечным состоянием итогового, составного вычисления.

Помимо этого для работы с монадой \Code{State} используются две вспомогательные функции \Code{put} и \Code{get}. Функция \Code{put} является вычислением, которое устанавливает состояние в заданное значение не зависимо от его предыдущего значения и не возвращает никакого результата (точнее возвращает кортеж нулевой длины \Code{()}). Функция \Code{get} возвращает текущее состояние и оставляет его без изменений. 

\section{Описание модели как вычислене с состоянием}

Описание модели на языке GPSS представляет из себя последовательность блоков. В Haskell такое описание удобно представить как последовательность функций, каждая из которых добавляет к уже сформированной модели очередной блок. 

Такой процесс удобно представить как вычисление с состоянием. Каждая функция, формирующая блок, помимо параметров самого блока должна принимать текущее состояние~--- список уже сформированных к данному моменту боков в пордке их формирования. В качестве результата функция возвращает новое состояние~--- модель к которой добавлен только что сформированный блок (см. Рисунок \ref{fig:StateIDEF}).

\begin{figure}[ht]
  \centering
  \includegraphics[width=\textwidth]{inc/dia/StateIDEF}
  \caption{Процесс формирования модели}
  \label{fig:StateIDEF}
\end{figure}

Для реализации такого механизма целесообразно воспользоваться монадой \Code{State}, что позволит скрыть явную передачу состояния от одной функции к другой. А использование нотации \Code{do} сделает описание модели почти идентичным синтаксису GPSS:

\begin{verbatim}

model = 
    do generate (10,2)
       advance 3
       terminate 1

\end{verbatim}


\section{Функции формирования блоков}

В языке GPSS имена всех блоков пишутся с заглавной буквы. Параметры отделяются от имени блока пробелом и разделяются запятыми. Синтаксис Haskell не позволяет в точности повторить эти соглашения. Имена функций в Haskell обязаны начинаться со строчной буквы. Параметры функций обычно разделяются пробелами и не берутся в скобки (каррированные функции) либо заключаются в скобки и разделяются запятыми (не каррированные функции)\footnote{Строго говоря все функции в Haskell принимают ровно один параметр. Функции от N парааметров на самом деле принимают один параметр и возвращают функцию от N-1 параметра (каррированные функции) либо принимают параметр-кортеж (некаррированные).}. Оба варианта описания параметров одинакоово близки к синтаксису GPSS и можно выбрать любой из них, однако для второго варианта существенно легче реализовать перегрузку функций.

\section{Перегрузка функций}
